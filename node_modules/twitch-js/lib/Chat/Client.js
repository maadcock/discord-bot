'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = require('eventemitter3');

var _qs = require('qs');

var _uws = require('../../shims/uws');

var _uws2 = _interopRequireDefault(_uws);

var _Queue = require('../Queue');

var _Queue2 = _interopRequireDefault(_Queue);

var _create = require('../utils/logger/create');

var _create2 = _interopRequireDefault(_create);

var _constants = require('./constants');

var constants = _interopRequireWildcard(_constants);

var _parsers = require('./utils/parsers');

var _parsers2 = _interopRequireDefault(_parsers);

var _validators = require('./utils/validators');

var validators = _interopRequireWildcard(_validators);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _Errors = require('./Errors');

var Errors = _interopRequireWildcard(_Errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var priority = constants.CLIENT_PRIORITY;

var Client = function (_EventEmitter) {
  _inherits(Client, _EventEmitter);

  function Client() {
    var maybeOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Client);

    // Validate options.
    var _this = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this));

    _this._pingTimeoutId = -1;
    _this._reconnectTimeoutId = -1;

    _this.isReady = function () {
      return (0, _get3.default)(_this, '_ws.readyState') === 1;
    };

    _this.send = function (message) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$priority = _ref.priority,
          priority = _ref$priority === undefined ? 1 : _ref$priority,
          isModerator = _ref.isModerator;

      var fn = _this._ws.send.bind(_this._ws, message);

      var queue = isModerator ? _this._moderatorQueue : _this._queue;

      var task = queue.push({ fn: fn, priority: priority });

      return new Promise(function (resolve, reject) {
        return task.on('accepted', function () {
          resolve();
          _this._log.debug('<', message);
        }).on('failed', function () {
          reject();
          _this._log.error('<', message);
        });
      });
    };

    _this.disconnect = function () {
      _this._handleKeepAliveReset();
      _this._ws.close();
    };

    _this._options = validators.clientOptions(maybeOptions);
    var _this$_options = _this._options,
        ssl = _this$_options.ssl,
        server = _this$_options.server,
        port = _this$_options.port,
        log = _this$_options.log;


    _this._log = (0, _create2.default)(_extends({ scope: 'Chat/Client' }, log));

    // Instantiate WebSocket.
    var protocol = ssl ? 'wss' : 'ws';
    _this._ws = new _uws2.default(protocol + '://' + server + ':' + port);

    _this._ws.onopen = _this._handleOpen.bind(_this);
    _this._ws.onmessage = _this._handleMessage.bind(_this);
    _this._ws.onerror = _this._handleError.bind(_this);
    _this._ws.onclose = _this._handleClose.bind(_this);

    // Instantiate Queue.
    _this._queue = _this._createQueue(_this._options);
    _this._moderatorQueue = _this._options.isVerified ? _this._queue : _this._createQueue({ isModerator: true });
    return _this;
  }

  /**
   * Send message to Twitch
   * @param {string} message
   * @param {Object} options
   * @param {number} options.priority
   * @param {boolean} options.isModerator
   */


  _createClass(Client, [{
    key: '_createQueue',
    value: function _createQueue(_ref2) {
      var isModerator = _ref2.isModerator,
          isVerified = _ref2.isVerified,
          isKnown = _ref2.isKnown;

      if (isModerator) {
        return new _Queue2.default({ maxLength: constants.RATE_LIMIT_MODERATOR });
      } else if (isVerified) {
        return new _Queue2.default({ maxLength: constants.RATE_LIMIT_VERIFIED_BOT });
      } else if (isKnown) {
        return new _Queue2.default({ maxLength: constants.RATE_LIMIT_KNOWN_BOT });
      }
      return new _Queue2.default();
    }
  }, {
    key: '_isUserAnonymous',
    value: function _isUserAnonymous() {
      return utils.isUserAnonymous((0, _get3.default)(this, '_options.username'));
    }
  }, {
    key: '_handleOpen',
    value: function _handleOpen() {
      // Register for Twitch-specific capabilities.
      this.send('CAP REQ :' + constants.CAPABILITIES.join(' '), { priority: priority });

      // Authenticate.
      var _options = this._options,
          token = _options.token,
          username = _options.username;

      this.send('PASS ' + token, { priority: priority });
      this.send('NICK ' + username, { priority: priority });
    }
  }, {
    key: '_handleMessage',
    value: function _handleMessage(messageEvent) {
      var _this2 = this;

      var rawMessage = messageEvent.data;

      try {
        this._handleKeepAlive();

        var messages = (0, _parsers2.default)(rawMessage);

        messages.forEach(function (message) {
          var event = message.command || '';

          _this2._log.debug('> %s %s', event, JSON.stringify(_extends({}, message, { _raw: undefined })));

          // Handle authentication failure.
          if (utils.isAuthenticationFailedMessage(message)) {
            _this2.emit(constants.EVENTS.AUTHENTICATION_FAILED, _extends({}, message, {
              event: constants.EVENTS.AUTHENTICATION_FAILED
            }));

            _this2.disconnect();
          } else {
            // Handle PING/PONG.
            if (message.command === constants.COMMANDS.PING) {
              _this2.send('PONG :tmi.twitch.tv', { priority: priority });
            }

            // Handle successful connections.
            if (_this2._isUserAnonymous()) {
              if (message.command === constants.COMMANDS.WELCOME) {
                _this2.emit(constants.EVENTS.CONNECTED, {
                  command: constants.EVENTS.CONNECTED
                });
              }
            } else {
              if (message.command === constants.COMMANDS.GLOBAL_USER_STATE) {
                _this2.emit(constants.EVENTS.CONNECTED, _extends({}, message, {
                  command: constants.EVENTS.CONNECTED
                }));
              }
            }

            // Handle RECONNECT.
            if (message.command === constants.COMMANDS.RECONNECT) {
              _this2.emit(constants.EVENTS.RECONNECT, _extends({}, message, {
                command: constants.EVENTS.RECONNECT
              }));
            }
          }

          // Emit all messages.
          _this2.emit(constants.EVENTS.ALL, message);
        });
      } catch (error) {
        var title = 'Parsing error encountered';
        var query = (0, _qs.stringify)({ title: title, body: rawMessage });
        this._log.error('Parsing error encountered. Please create an issue: %s', 'https://github.com/twitch-devs/twitch-js/issues/new?' + query, error);

        var message = new Errors.ParseError(error, rawMessage);

        this.emit(message.command, message);
        this.emit(constants.EVENTS.ALL, message);
        throw message;
      } finally {
        var _message = {
          _raw: rawMessage,
          timestamp: new Date()
        };

        this.emit(constants.EVENTS.RAW, _message);
      }
    }
  }, {
    key: '_handleError',
    value: function _handleError(messageEvent) {
      var message = {
        timestamp: new Date(),
        event: constants.EVENTS.ERROR_ENCOUNTERED,
        messageEvent: messageEvent
      };

      this.emit(constants.EVENTS.ERROR_ENCOUNTERED, message);
      this.emit(constants.EVENTS.ALL, message);
    }
  }, {
    key: '_handleClose',
    value: function _handleClose(messageEvent) {
      var message = {
        timestamp: new Date(),
        event: constants.EVENTS.DISCONNECTED,
        messageEvent: messageEvent
      };

      this.emit(constants.EVENTS.DISCONNECTED, message);
      this.emit(constants.EVENTS.ALL, message);
    }
  }, {
    key: '_handleKeepAlive',
    value: function _handleKeepAlive() {
      var _this3 = this;

      this._handleKeepAliveReset();

      if (this.isReady()) {
        this._pingTimeoutId = setTimeout(function () {
          return _this3.send(constants.COMMANDS.PING, { priority: priority });
        }, constants.KEEP_ALIVE_PING_TIMEOUT);
      }

      this._reconnectTimeoutId = setTimeout(function () {
        return _this3.emit(constants.EVENTS.RECONNECT, {});
      }, constants.KEEP_ALIVE_RECONNECT_TIMEOUT);
    }
  }, {
    key: '_handleKeepAliveReset',
    value: function _handleKeepAliveReset() {
      clearTimeout(this._pingTimeoutId);
      clearTimeout(this._reconnectTimeoutId);
      this._pingTimeoutId = -1;
      this._reconnectTimeoutId = -1;
    }
  }]);

  return Client;
}(_eventemitter.EventEmitter);

exports.default = Client;
//# sourceMappingURL=Client.js.map