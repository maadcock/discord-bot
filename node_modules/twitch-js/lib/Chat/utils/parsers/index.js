'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.privateMessage = exports.userNoticeMessage = exports.noticeMessage = exports.roomStateMessage = exports.userStateMessage = exports.globalUserStateMessage = exports.clearChatMessage = exports.namesEndMessage = exports.namesMessage = exports.joinOrPartMessage = exports.hostTargetMessage = exports.modeMessage = undefined;

var _toUpper2 = require('lodash/toUpper');

var _toUpper3 = _interopRequireDefault(_toUpper2);

var _toNumber2 = require('lodash/toNumber');

var _toNumber3 = _interopRequireDefault(_toNumber2);

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _ircMessage = require('irc-message');

var _camelcaseKeys = require('camelcase-keys');

var _camelcaseKeys2 = _interopRequireDefault(_camelcaseKeys);

var _constants = require('../../constants');

var constants = _interopRequireWildcard(_constants);

var _ = require('../');

var utils = _interopRequireWildcard(_);

var _types = require('./types');

var typeParsers = _interopRequireWildcard(_types);

var _tags = require('./tags');

var tagParsers = _interopRequireWildcard(_tags);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var base = function base(rawMessages) {
  var rawMessagesV = rawMessages.split(/\r?\n/g);
  var messages = [];

  rawMessagesV.forEach(function (rawMessage) {
    if (!rawMessage.length) {
      return;
    }

    var _parse = (0, _ircMessage.parse)(rawMessage),
        raw = _parse.raw,
        tags = _parse.tags,
        command = _parse.command,
        prefix = _parse.prefix,
        _parse$params = _slicedToArray(_parse.params, 2),
        channel = _parse$params[0],
        message = _parse$params[1];

    /**
     * Base message parsed from Twitch
     * @mixin BaseMessage
     * @property {string} _raw Un-parsed message
     * @property {Date} timestamp Timestamp
     * @property {string} username Username
     * @property {string} command Command
     * @property {string} [channel] Channel
     * @property {(ClearChatTags|GlobalUserStateTags|PrivateMessageTags|RoomStateTags|UserNoticeTags|UserStateTags)} tags Twitch tags
     * @property {string} [message] Message
     */


    messages.push({
      _raw: raw,
      timestamp: typeParsers.generalTimestamp(parseInt(tags['tmi-sent-ts'], 10)),
      username: typeParsers.usernameFromPrefix(prefix),
      command: command,
      channel: channel !== '*' ? channel : '',
      tags: (0, _isEmpty3.default)(tags) ? {} : (0, _camelcaseKeys2.default)(tags),
      message: message
    });
  });

  return messages;
};

var joinOrPartMessage = function joinOrPartMessage(baseMessage) {
  var _$exec = /:(.+)!(.+)@(.+).tmi.twitch.tv (JOIN|PART) (#.+)/g.exec(baseMessage._raw),
      _$exec2 = _slicedToArray(_$exec, 6),
      username = _$exec2[1],
      command = _$exec2[4],
      channel = _$exec2[5];

  /**
   * Join a channel.
   * @event Chat#JOIN
   * @mixes BaseMessage JoinOrPartMessage
   * @property {string} username Username (lower-case)
   * @see https://dev.twitch.tv/docs/irc/membership/#join-twitch-membership
   */
  /**
   * Depart from a channel.
   * @event Chat#PART
   * @mixes BaseMessage JoinOrPartMessage
   * @property {string} username Username (lower-case)
   * @see https://dev.twitch.tv/docs/irc/membership/#part-twitch-membership
   */


  return _extends({}, baseMessage, {
    channel: channel,
    command: command,
    username: username,
    message: undefined
  });
};

var modeMessage = function modeMessage(baseMessage) {
  var _$exec3 = /:[^\s]+ MODE (#[^\s]+) (-|\+)o ([^\s]+)/g.exec(baseMessage._raw),
      _$exec4 = _slicedToArray(_$exec3, 4),
      channel = _$exec4[1],
      mode = _$exec4[2],
      username = _$exec4[3];

  var isModerator = mode === '+';

  /**
   * Gain/lose moderator (operator) status in a channel.
   * @event Chat#MODE
   * @mixes BaseMessage ModeMessage
   * @property {string} event
   * @property {string} username
   * @property {boolean} isModerator
   * @see https://dev.twitch.tv/docs/irc/membership/#mode-twitch-membership
   */
  return _extends({}, baseMessage, {
    event: isModerator ? constants.EVENTS.MOD_GAINED : constants.EVENTS.MOD_LOST,
    channel: channel,
    username: username,
    message: mode + 'o',
    isModerator: isModerator
  });
};

var namesMessage = function namesMessage(baseMessage) {
  var _$exec5 = /:(.+).tmi.twitch.tv 353 (.+) = (#.+) :(.+)/g.exec(baseMessage._raw),
      _$exec6 = _slicedToArray(_$exec5, 5),
      channel = _$exec6[3],
      names = _$exec6[4];

  var namesV = names.split(' ');

  /**
   * List current chatters in a channel.
   * @event Chat#NAMES
   * @mixes BaseMessage NamesMessage
   * @property {Array<string>} usernames Array of usernames present in channel
   * @see https://dev.twitch.tv/docs/irc/membership/#names-twitch-membership
   */
  return _extends({}, baseMessage, {
    channel: channel,
    event: constants.EVENTS.NAMES,
    usernames: namesV,
    message: undefined
  });
};

var namesEndMessage = function namesEndMessage(baseMessage) {
  var _$exec7 = /:(.+).tmi.twitch.tv 366 (.+) (#.+) :(.+)/g.exec(baseMessage._raw),
      _$exec8 = _slicedToArray(_$exec7, 5),
      username = _$exec8[1],
      channel = _$exec8[3],
      message = _$exec8[4];

  /**
   * End of list current chatters in a channel.
   * @event Chat#NAMES_END
   * @mixes BaseMessage NamesEndMessage
   * @see https://dev.twitch.tv/docs/irc/membership/#names-twitch-membership
   */


  return _extends({}, baseMessage, {
    channel: channel,
    event: constants.EVENTS.NAMES_END,
    username: username,
    message: message
  });
};

var globalUserStateMessage = function globalUserStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * GLOBALUSERSTATE message
   * @mixin GlobalUserStateMessage
   * @mixes BaseMessage
   * @property {GlobalUserStateTags} tags
   */
  /**
   * On successful login.
   * @event Chat#GLOBALUSERSTATE
   * @mixes GlobalUserStateMessage
   */


  return _extends({
    tags: tagParsers.globalUserState(tags)
  }, other);
};

var clearChatMessage = function clearChatMessage(baseMessage) {
  var tags = baseMessage.tags,
      username = baseMessage.message,
      other = _objectWithoutProperties(baseMessage, ['tags', 'message']);

  if (typeof username !== 'undefined') {
    /**
     * Temporary or permanent ban on a channel.
     * @event Chat#CLEARCHAT/USER_BANNED
     * @mixes BaseMessage ClearChatUserBannedMessage
     * @property {ClearChatTags} tags
     * @property {string} username
     * @see https://dev.twitch.tv/docs/irc/commands/#clearchat-twitch-commands
     * @see https://dev.twitch.tv/docs/irc/tags/#clearchat-twitch-tags
     */
    return _extends({}, other, {
      tags: _extends({}, tags, {
        banReason: typeParsers.generalString(tags.banReason),
        banDuration: typeParsers.generalNumber(tags.banDuration)
      }),
      event: constants.EVENTS.USER_BANNED,
      username: username
    });
  }

  /**
   * All chat is cleared (deleted).
   * @event Chat#CLEARCHAT
   * @mixes BaseMessage ClearChatMessage
   * @see https://dev.twitch.tv/docs/irc/commands/#clearchat-twitch-commands
   * @see https://dev.twitch.tv/docs/irc/tags/#clearchat-twitch-tags
   */
  return _extends({}, other);
};

var hostTargetMessage = function hostTargetMessage(baseMessage) {
  var _$exec9 = /:tmi.twitch.tv HOSTTARGET (#[^\s]+) :([^\s]+)?\s?(\d+)?/g.exec(baseMessage._raw),
      _$exec10 = _slicedToArray(_$exec9, 4),
      channel = _$exec10[1],
      username = _$exec10[2],
      numberOfViewers = _$exec10[3];

  var isStopped = username === '-';

  /**
   * Host starts or stops a message.
   * @event Chat#HOSTTARGET
   * @mixes BaseMessage HostTargetMessage
   * @property {number} [numberOfViewers] Number of viewers
   * @see https://dev.twitch.tv/docs/irc/commands/#hosttarget-twitch-commands
   */
  return _extends({}, baseMessage, {
    channel: channel,
    username: username,
    event: (0, _toUpper3.default)(isStopped ? constants.NOTICE_MESSAGE_IDS.HOST_OFF : constants.NOTICE_MESSAGE_IDS.HOST_ON),
    numberOfViewers: (0, _isFinite3.default)((0, _toNumber3.default)(numberOfViewers)) ? parseInt(numberOfViewers, 10) : undefined,
    message: undefined
  });
};

var roomStateMessage = function roomStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * When a user joins a channel or a room setting is changed.
   * @event Chat#ROOMSTATE
   * @mixes BaseMessage RoomStateMessage
   * @property {RoomStateTags} tags
   */


  return _extends({
    tags: tagParsers.roomState(tags)
  }, other);
};

var noticeMessage = function noticeMessage(baseMessage) {
  var baseTags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  var tags = utils.isAuthenticationFailedMessage(baseMessage) ? _extends({}, baseTags, { msgId: constants.EVENTS.AUTHENTICATION_FAILED }) : baseTags;

  var event = (0, _toUpper3.default)(tags.msgId);

  switch (tags.msgId) {
    case constants.NOTICE_MESSAGE_IDS.ROOM_MODS:
      /**
       * NOTICE/ROOM_MODS message
       * @event Chat#NOTICE/ROOM_MODS
       * @mixes NoticeMessage NoticeMessage
       * @property {'ROOM_MODS'} event
       * @property {Array<string>} mods
       */
      return _extends({ event: event, tags: tags, mods: typeParsers.mods(other.message) }, other);
    default:
      /**
       * @event Chat#NOTICE
       * @mixes NoticeMessage
       * @property {string} event `msg-id` tag (snake uppercase)
       * @property {Object} tags
       * @see https://dev.twitch.tv/docs/irc/commands/#msg-id-tags-for-the-notice-commands-capability
       */

      /**
       * NOTICE message
       * @mixin NoticeMessage
       * @property {string} event `msg-id` tag (snake uppercase)
       * @property {Object} tags
       */
      return _extends({ event: event, tags: tags }, other);
  }
};

var userStateMessage = function userStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * USERSTATE message
   * @mixin UserStateMessage
   * @mixes BaseMessage
   * @property {UserStateTags} tags
   */
  /**
   * When a user joins a channel or sends a PRIVMSG to a channel.
   * @event Chat#USERSTATE
   * @mixes UserStateMessage UserStateMessage
   */


  return _extends({
    tags: tagParsers.userState(tags)
  }, other);
};

/**
 * When a user joins a channel or sends a PRIVMSG to a channel.
 * @event Chat#PRIVMSG
 * @mixes UserStateMessage PrivateMessage
 */
var privateMessage = function privateMessage(baseMessage) {
  var _raw = baseMessage._raw,
      tags = baseMessage.tags;


  if ((0, _has3.default)(baseMessage, 'tags.bits')) {
    /**
     * When a user cheers a channel.
     * @event Chat#PRIVMSG/CHEER
     * @mixes UserStateMessage PrivateMessage
     * @property {'CHEER'} event
     * @property {number} bits
     */
    return _extends({}, userStateMessage(baseMessage), tagParsers.privateMessageCheerEvent(tags));
  }

  var _ref = constants.PRIVATE_MESSAGE_HOSTED_RE.exec(_raw) || [],
      _ref2 = _slicedToArray(_ref, 5),
      isHostingPrivateMessage = _ref2[0],
      channel = _ref2[1],
      displayName = _ref2[2],
      isAuto = _ref2[3],
      numberOfViewers = _ref2[4];

  if (isHostingPrivateMessage) {
    /**
     * When a user hosts your channel while connected as broadcaster.
     * @event Chat#PRIVMSG/HOSTED
     * @mixes UserStateMessage PrivateMessage
     * @property {'HOSTED/WITH_VIEWERS'|'HOSTED/WITHOUT_VIEWERS'|'HOSTED/AUTO'} event
     * @property {Object} tags
     * @property {string} tags.displayName
     * @property {number} [numberOfViewers]
     */

    return _extends({}, baseMessage, {
      tags: { displayName: displayName },
      channel: '#' + channel,
      event: isAuto ? constants.EVENTS.HOSTED_AUTO : numberOfViewers ? constants.EVENTS.HOSTED_WITH_VIEWERS : constants.EVENTS.HOSTED_WITHOUT_VIEWERS,
      numberOfViewers: typeParsers.generalNumber(numberOfViewers)
    });
  }

  return userStateMessage(baseMessage);
};

/**
 * USERNOTICE message
 * @mixin UserNoticeMessage
 * @mixes BaseMessage
 * @property {string} event
 * @property {Object} parameters
 * @property {string} systemMessage
 */
var userNoticeMessage = function userNoticeMessage(baseMessage) {
  var tags = tagParsers.userNotice(baseMessage.tags);

  /* eslint-disable no-fallthrough */
  switch (tags.msgId) {
    /**
     * On anonymous gifted subscription paid upgrade to a channel.
     * @event Chat#USERNOTICE/ANON_GIFT_PAID_UPGRADE
     * @mixes UserStateMessage AnonGiftPaidUpgradeMessage
     * @property {'ANON_GIFT_PAID_UPGRADE'} event
     */
    case constants.USER_NOTICE_MESSAGE_IDS.ANON_GIFT_PAID_UPGRADE:

    /**
     * On gifted subscription paid upgrade to a channel.
     * @event Chat#USERNOTICE/GIFT_PAID_UPGRADE
     * @mixes UserStateMessage GiftPaidUpgradeMessage
     * @property {'GIFT_PAID_UPGRADE'} event
     * @property {Object} parameters
     * @property {number} parameters.promoGiftTotal
     * @property {string} parameters.promoName
     * @property {string} parameters.senderLogin
     * @property {string} parameters.senderName
     */
    case constants.USER_NOTICE_MESSAGE_IDS.GIFT_PAID_UPGRADE:

    /**
     * On channel raid.
     * @event Chat#USERNOTICE/RAID
     * @mixes UserStateMessage
     * @property {'RAID'} event
     * @property {Object} parameters
     * @property {string} parameters.displayName
     * @property {string} parameters.login
     * @property {number} parameters.viewerCount
     */
    case constants.USER_NOTICE_MESSAGE_IDS.RAID:

    /**
     * On resubscription (subsequent months) to a channel.
     * @event Chat#USERNOTICE/RESUBSCRIPTION
     * @mixes UserStateMessage
     * @property {'RESUBSCRIPTION'} event
     * @property {Object} parameters
     * @property {number} parameters.months
     * @property {string} parameters.subPlan
     * @property {string} parameters.subPlanName
     */
    case constants.USER_NOTICE_MESSAGE_IDS.RESUBSCRIPTION:

    /**
     * On channel ritual.
     * @event Chat#USERNOTICE/RITUAL
     * @mixes UserStateMessage
     * @property {'RITUAL'} event
     * @property {Object} parameters
     * @property {string} parameters.ritualName
     */
    case constants.USER_NOTICE_MESSAGE_IDS.RITUAL:

    /**
     * On subscription gift to a channel community.
     * @event Chat#USERNOTICE/SUBSCRIPTION_GIFT_COMMUNITY
     * @mixes UserStateMessage
     * @property {'SUBSCRIPTION_GIFT_COMMUNITY'} event
     * @property {Object} parameters
     * @property {number} parameters.massGiftCount
     * @property {number} parameters.senderCount
     * @property {string} parameters.subPlan
     */
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION_GIFT_COMMUNITY:

    /**
     * On subscription gift to a channel.
     * @event Chat#USERNOTICE/SUBSCRIPTION_GIFT
     * @mixes UserStateMessage
     * @property {'SUBSCRIPTION_GIFT'} event
     * @property {Object} parameters
     * @property {number} parameters.months
     * @property {string} parameters.subPlan
     * @property {string} parameters.subPlanName
     * @property {string} parameters.recipientDisplayName
     * @property {string} parameters.recipientId
     * @property {string} parameters.recipientName
     */
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION_GIFT:

    /**
     * On subscription (first month) to a channel.
     * @event Chat#USERNOTICE/SUBSCRIPTION
     * @mixes UserStateMessage
     * @property {'SUBSCRIPTION'} event
     * @property {Object} parameters
     * @property {1} parameters.months
     * @property {string} parameters.subPlan
     * @property {string} parameters.subPlanName
     */
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION:

    default:
      return _extends({}, baseMessage, {
        tags: _extends({}, tags, { systemMsg: typeParsers.generalString(tags.systemMsg) }),
        parameters: tagParsers.userNoticeMessageParameters(tags),
        event: tagParsers.userNoticeEvent(tags),
        systemMessage: typeParsers.generalString(tags.systemMsg)
      });
  }
  /* eslint-enable no-fallthrough */
};

exports.modeMessage = modeMessage;
exports.hostTargetMessage = hostTargetMessage;
exports.joinOrPartMessage = joinOrPartMessage;
exports.namesMessage = namesMessage;
exports.namesEndMessage = namesEndMessage;
exports.clearChatMessage = clearChatMessage;
exports.globalUserStateMessage = globalUserStateMessage;
exports.userStateMessage = userStateMessage;
exports.roomStateMessage = roomStateMessage;
exports.noticeMessage = noticeMessage;
exports.userNoticeMessage = userNoticeMessage;
exports.privateMessage = privateMessage;
exports.default = base;
//# sourceMappingURL=index.js.map