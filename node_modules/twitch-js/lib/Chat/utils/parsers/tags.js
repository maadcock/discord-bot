'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.userState = exports.userNoticeEvent = exports.userNoticeMessageParameters = exports.userNotice = exports.roomState = exports.privateMessageCheerEvent = exports.privateMessage = exports.globalUserState = exports.clearChat = undefined;

var _toUpper2 = require('lodash/toUpper');

var _toUpper3 = _interopRequireDefault(_toUpper2);

var _toLower2 = require('lodash/toLower');

var _toLower3 = _interopRequireDefault(_toLower2);

var _gt2 = require('lodash/gt');

var _gt3 = _interopRequireDefault(_gt2);

var _camelCase2 = require('lodash/camelCase');

var _camelCase3 = _interopRequireDefault(_camelCase2);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _constants = require('../../constants');

var constants = _interopRequireWildcard(_constants);

var _types = require('./types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * CLEARCHAT tags
 * @typedef {Object} ClearChatTags
 * @property {string} [banReason]
 * @property {number} [banDuration]
 * @see https://dev.twitch.tv/docs/irc/tags#clearchat-twitch-tags
 */
var clearChat = function clearChat(tags) {
  return _extends({}, tags, {
    banReason: types.generalString(tags.banReason),
    banDuration: types.generalNumber(tags.banDuration)
  });
};

/**
 * GLOBALUSERSTATE tags
 * @typedef {Object} GlobalUserStateTags
 * @property {Array<string>} emoteSets
 * @property {string} userType
 * @property {string} username
 * @see https://dev.twitch.tv/docs/irc/tags#globaluserstate-twitch-tags
 */
var globalUserState = function globalUserState(tags) {
  return _extends({}, tags, {
    emoteSets: types.emoteSets(tags.emoteSets),
    userType: types.userType(tags.userType),
    username: (0, _toLower3.default)(tags.displayName)
  });
};

/** PRIVMSG tags
 * @typedef {UserStateTags} PrivateMessageTags
 * @see https://dev.twitch.tv/docs/irc/tags#privmsg-twitch-tags
 */
var privateMessage = function privateMessage() {
  return userState.apply(undefined, arguments);
};

var privateMessageCheerEvent = function privateMessageCheerEvent(tags) {
  return (0, _gt3.default)(tags.bits, 0) ? { event: constants.EVENTS.CHEER, bits: parseInt(tags.bits, 10) } : {};
};

/**
 * ROOMSTATE Tag
 * @typedef {Object} RoomStateTags
 * @property {string} [broadcasterLang]
 * @property {booelan} emoteOnly
 * @property {boolean|number} followersOnly
 * @property {boolean} r9k
 * @property {number} slow
 * @property {boolean} subsOnly
 * @see https://dev.twitch.tv/docs/irc/tags#roomstate-twitch-tags
 */
var roomState = function roomState(roomStateTags) {
  return Object.entries(roomStateTags).reduce(function (tags, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        tag = _ref2[0],
        value = _ref2[1];

    switch (tag) {
      case 'followersOnly':
        return _extends({}, tags, _defineProperty({}, tag, types.followersOnly(value)));
      // Strings
      case 'broadcasterLang':
        return _extends({}, tags, _defineProperty({}, tag, types.generalString(value)));
      // Numbers
      case 'slow':
        return _extends({}, tags, _defineProperty({}, tag, types.generalNumber(value)));
      // Booleans
      case 'emoteOnly':
      case 'r9k':
      case 'subsOnly':
        return _extends({}, tags, _defineProperty({}, tag, types.generalBoolean(value)));
      default:
        return _extends({}, tags, _defineProperty({}, tag, value));
    }
  }, {});
};

/** USERNOTICE tags
 * @typedef {UserStateTags} UserNoticeTags
 * @see https://dev.twitch.tv/docs/irc/tags#usernotice-twitch-tags
 */
var userNotice = function userNotice() {
  return userState.apply(undefined, arguments);
};

var userNoticeMessageParameters = function userNoticeMessageParameters(tags) {
  return Object.entries(tags).reduce(function (parameters, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        tag = _ref4[0],
        value = _ref4[1];

    var _ref5 = constants.MESSAGE_PARAMETER_PREFIX_RE.exec(tag) || [],
        _ref6 = _slicedToArray(_ref5, 2),
        param = _ref6[1];

    switch (param) {
      // Numbers.
      case 'Months':
      case 'MassGiftCount':
      case 'PromoGiftTotal':
      case 'SenderCount':
      case 'ViewerCount':
        return _extends({}, parameters, _defineProperty({}, (0, _camelCase3.default)(param), types.generalNumber(value)));
      // Not a msgParam.
      case undefined:
        return parameters;
      // Strings
      default:
        return _extends({}, parameters, _defineProperty({}, (0, _camelCase3.default)(param), types.generalString(value)));
    }
  }, {});
};

var userNoticeEvent = function userNoticeEvent(tags) {
  switch (tags.msgId) {
    case constants.USER_NOTICE_MESSAGE_IDS.ANON_GIFT_PAID_UPGRADE:
      return constants.EVENTS.ANON_GIFT_PAID_UPGRADE;
    case constants.USER_NOTICE_MESSAGE_IDS.GIFT_PAID_UPGRADE:
      return constants.EVENTS.GIFT_PAID_UPGRADE;
    case constants.USER_NOTICE_MESSAGE_IDS.RESUBSCRIPTION:
      return constants.EVENTS.RESUBSCRIPTION;
    case constants.USER_NOTICE_MESSAGE_IDS.RAID:
      return constants.EVENTS.RAID;
    case constants.USER_NOTICE_MESSAGE_IDS.RITUAL:
      return constants.EVENTS.RITUAL;
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION:
      return constants.EVENTS.SUBSCRIPTION;
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION_GIFT:
      return constants.EVENTS.SUBSCRIPTION_GIFT;
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION_GIFT_COMMUNITY:
      return constants.EVENTS.SUBSCRIPTION_GIFT_COMMUNITY;
    default:
      return (0, _toUpper3.default)(tags.msgId);
  }
};

/**
 * USERSTATE tags
 * @typedef {Object} UserStateTags
 * @property {BadgesTag} badges
 * @property {Array<EmoteTag>} emotes
 * @property {Array<string>} emoteSets
 * @property {number} [bits]
 * @see https://dev.twitch.tv/docs/irc/tags#userstate-twitch-tags
 */
var userState = function userState(tags) {
  return _extends({}, tags, {
    badges: types.badges(tags.badges),
    bits: types.generalNumber(tags.bits),
    emotes: types.emotes(tags.emotes),
    emoteSets: types.emoteSets(tags.emoteSets),
    userType: types.userType(tags.userType)
  });
};

exports.clearChat = clearChat;
exports.globalUserState = globalUserState;
exports.privateMessage = privateMessage;
exports.privateMessageCheerEvent = privateMessageCheerEvent;
exports.roomState = roomState;
exports.userNotice = userNotice;
exports.userNoticeMessageParameters = userNoticeMessageParameters;
exports.userNoticeEvent = userNoticeEvent;
exports.userState = userState;
//# sourceMappingURL=tags.js.map