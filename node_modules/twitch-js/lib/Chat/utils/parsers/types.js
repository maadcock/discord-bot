'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mods = exports.emoteSets = exports.emotes = exports.badges = exports.followersOnly = exports.broadcasterLanguage = exports.userType = exports.usernameFromPrefix = exports.generalTimestamp = exports.generalBoolean = exports.generalNumber = exports.generalString = undefined;

var _camelCase2 = require('lodash/camelCase');

var _camelCase3 = _interopRequireDefault(_camelCase2);

var _replace2 = require('lodash/replace');

var _replace3 = _interopRequireDefault(_replace2);

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var generalString = function generalString(maybeMessage) {
  return typeof maybeMessage === 'string' ? (0, _replace3.default)(maybeMessage, /\\[sn]/g, ' ') : undefined;
};

var generalNumber = function generalNumber(maybeNumber) {
  var number = parseInt(maybeNumber, 10);
  return (0, _isFinite3.default)(number) ? number : undefined;
};

var generalBoolean = function generalBoolean(maybeBoolean) {
  return maybeBoolean === '1';
};

var generalTimestamp = function generalTimestamp(maybeTimestamp) {
  var timestamp = new Date(parseInt(maybeTimestamp, 10));
  return timestamp.toString() !== 'Invalid Date' ? timestamp : new Date();
};

var usernameFromPrefix = function usernameFromPrefix(maybePrefix) {
  if (typeof maybePrefix !== 'string') {
    return undefined;
  }

  var _$exec = /([^!]+)/.exec(maybePrefix),
      _$exec2 = _slicedToArray(_$exec, 2),
      username = _$exec2[1];

  return username;
};

var userType = function userType(maybeUserType) {
  return typeof maybeUserType === 'string' ? maybeUserType : undefined;
};

var broadcasterLanguage = function broadcasterLanguage(maybeLanguage) {
  return typeof maybeLanguage === 'string' ? maybeLanguage : undefined;
};

var followersOnly = function followersOnly(maybeFollowersOnly) {
  var followersOnlyAsNumber = parseInt(maybeFollowersOnly, 10);

  if (followersOnlyAsNumber === 0) {
    return true;
  } else if (followersOnlyAsNumber > 0) {
    return followersOnlyAsNumber;
  }

  return false;
};

var badges = function badges(maybeBadges) {
  /**
   * Badges tag
   * @typedef {Object} BadgesTag
   * @property {boolean} [admin]
   * @property {number} [bits]
   * @property {number} [bitsLeader]
   * @property {boolean} [broadcaster]
   * @property {boolean} [globalMod]
   * @property {boolean} [moderator]
   * @property {boolean} [partner]
   * @property {boolean} [premium]
   * @property {boolean} [staff]
   * @property {boolean} [subGifter]
   * @property {number} [subscriber]
   * @property {boolean} [turbo]
   * @property {boolean} [vip]
   * @see https://dev.twitch.tv/docs/irc/tags/#privmsg-twitch-tags
   */
  return typeof maybeBadges === 'string' ? maybeBadges.split(',').reduce(function (parsed, badge) {
    var _badge$split = badge.split('/'),
        _badge$split2 = _slicedToArray(_badge$split, 2),
        rawKey = _badge$split2[0],
        value = _badge$split2[1];

    var key = (0, _camelCase3.default)(rawKey);

    switch (key) {
      // Booleans
      case 'admin':
      case 'broadcaster':
      case 'globalMod':
      case 'moderator':
      case 'partner':
      case 'premium':
      case 'staff':
      case 'subGifter':
      case 'turbo':
      case 'vip':
        return _extends({}, parsed, _defineProperty({}, key, generalBoolean(value)));
      // Numbers
      case 'bits':
      case 'bitsLeader':
      case 'subscriber':
        return _extends({}, parsed, _defineProperty({}, key, parseInt(value, 10)));
      default:
        return _extends({}, parsed, _defineProperty({}, key, value));
    }
  }, {}) : {};
};

var emotes = function emotes(maybeEmotes) {
  if (typeof maybeEmotes !== 'string') {
    return [];
  }

  /**
   * Emote tag
   * @typedef {Object} EmoteTag
   * @property {string} id ID
   * @property {number} start Starting index
   * @property {number} end Ending index
   * @see https://dev.twitch.tv/docs/irc/tags/#privmsg-twitch-tags
   */
  return maybeEmotes.split('/').reduce(function (emoteTag, emoteIndices) {
    var _emoteIndices$split = emoteIndices.split(':'),
        _emoteIndices$split2 = _slicedToArray(_emoteIndices$split, 2),
        id = _emoteIndices$split2[0],
        indices = _emoteIndices$split2[1];

    return [].concat(_toConsumableArray(emoteTag), _toConsumableArray(indices.split(',').map(function (index) {
      var _index$split = index.split('-'),
          _index$split2 = _slicedToArray(_index$split, 2),
          start = _index$split2[0],
          end = _index$split2[1];

      return { id: id, start: parseInt(start, 10), end: parseInt(end, 10) };
    })));
  }, []);
};

var emoteSets = function emoteSets(maybeEmoteSets) {
  return typeof maybeEmoteSets === 'string' ? maybeEmoteSets.split(',') : undefined;
};

var mods = function mods(message) {
  var _message$split = message.split(': '),
      _message$split2 = _slicedToArray(_message$split, 2),
      modList = _message$split2[1];

  return modList.split(', ');
};

exports.generalString = generalString;
exports.generalNumber = generalNumber;
exports.generalBoolean = generalBoolean;
exports.generalTimestamp = generalTimestamp;
exports.usernameFromPrefix = usernameFromPrefix;
exports.userType = userType;
exports.broadcasterLanguage = broadcasterLanguage;
exports.followersOnly = followersOnly;
exports.badges = badges;
exports.emotes = emotes;
exports.emoteSets = emoteSets;
exports.mods = mods;
//# sourceMappingURL=types.js.map