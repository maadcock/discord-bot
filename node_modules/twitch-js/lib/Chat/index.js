'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constants = undefined;

var _get3 = require('lodash/get');

var _get4 = _interopRequireDefault(_get3);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventemitter = require('eventemitter3');

var _create = require('../utils/logger/create');

var _create2 = _interopRequireDefault(_create);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _utils2 = require('./utils');

var chatUtils = _interopRequireWildcard(_utils2);

var _Client = require('./Client');

var _Client2 = _interopRequireDefault(_Client);

var _Errors = require('./Errors');

var Errors = _interopRequireWildcard(_Errors);

var _constants = require('./constants');

var constants = _interopRequireWildcard(_constants);

var _commands = require('./utils/commands');

var commands = _interopRequireWildcard(_commands);

var _parsers = require('./utils/parsers');

var parsers = _interopRequireWildcard(_parsers);

var _sanitizers = require('./utils/sanitizers');

var sanitizers = _interopRequireWildcard(_sanitizers);

var _validators = require('./utils/validators');

var validators = _interopRequireWildcard(_validators);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * EventEmitter3 is a high performance EventEmitter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @external EventEmitter3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @see {@link https://github.com/primus/eventemitter3 EventEmitter3}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class
 * @public
 * @extends EventEmitter
 * @classdesc Twitch Chat Client
 *
 * @emits Chat#*
 * @emits Chat#CLEARCHAT
 * @emits Chat#CLEARCHAT/USER_BANNED
 * @emits Chat#GLOBALUSERSTATE
 * @emits Chat#HOSTTARGET
 * @emits Chat#JOIN
 * @emits Chat#MODE
 * @emits Chat#NAMES
 * @emits Chat#NAMES_END
 * @emits Chat#NOTICE
 * @emits Chat#NOTICE/ROOM_MODS
 * @emits Chat#PART
 * @emits Chat#PRIVMSG
 * @emits Chat#PRIVMSG/CHEER
 * @emits Chat#ROOMSTATE
 * @emits Chat#USERNOTICE
 * @emits Chat#USERNOTICE/ANON_GIFT_PAID_UPGRADE
 * @emits Chat#USERNOTICE/GIFT_PAID_UPGRADE
 * @emits Chat#USERNOTICE/RAID
 * @emits Chat#USERNOTICE/RESUBSCRIPTION
 * @emits Chat#USERNOTICE/RITUAL
 * @emits Chat#USERNOTICE/SUBSCRIPTION
 * @emits Chat#USERNOTICE/SUBSCRIPTION_GIFT
 * @emits Chat#USERSTATE
 *
 * @example <caption>Connecting to Twitch and joining #dallas</caption>
 * const token = 'cfabdegwdoklmawdzdo98xt2fo512y'
 * const username = 'ronni'
 * const channel = '#dallas'
 * const { chat } = new TwitchJs({ token, username })
 *
 * chat.connect().then(globalUserState => {
 *   // Listen to all messages
 *   chat.on('*', message => {
 *     // Do stuff with message ...
 *   })
 *
 *   // Listen to PRIVMSG
 *   chat.on('PRIVMSG', privateMessage => {
 *     // Do stuff with privateMessage ...
 *   })
 *
 *   // Do other stuff ...
 *
 *   chat.join(channel).then(channelState => {
 *     // Do stuff with channelState...
 *   })
 * })
 */
var Chat = function (_EventEmitter) {
  _inherits(Chat, _EventEmitter);

  /**
   * Chat constructor.
   * @param {ChatOptions} options
   */


  /** @private */


  /** @private */

  /** @private */


  /** @private */
  function Chat(maybeOptions) {
    _classCallCheck(this, Chat);

    var _this = _possibleConstructorReturn(this, (Chat.__proto__ || Object.getPrototypeOf(Chat)).call(this));

    _this._readyState = 0;
    _this._connectionAttempts = 0;
    _this._connectionInProgress = null;
    _this._userState = {};
    _this._channelState = {};

    _this.connect = function () {
      if (_this._connectionInProgress) {
        return _this._connectionInProgress;
      }

      _this._connectionInProgress = Promise.race([utils.rejectAfter(_this.options.connectionTimeout, new Errors.TimeoutError(constants.ERROR_CONNECT_TIMED_OUT)), _this._handleConnectionAttempt()]).then(_this._handleConnectSuccess.bind(_this)).catch(_this._handleConnectRetry.bind(_this));

      return _this._connectionInProgress;
    };

    _this.send = function (message, options) {
      return _this._client.send(message, options);
    };

    _this.disconnect = function () {
      return _this._client.disconnect();
    };

    _this.reconnect = function (newOptions) {
      if (newOptions) {
        _this.options = _extends({}, _this.options, newOptions);
      }

      _this._connectionInProgress = null;
      _this._readyState = 2;

      var channels = _this._getChannels();
      _this.disconnect();

      return _this.connect().then(function () {
        return Promise.all(channels.map(function (channel) {
          return _this.join(channel);
        }));
      });
    };

    _this.join = function (maybeChannel) {
      var channel = sanitizers.channel(maybeChannel);

      _this._log.info('Joining ' + channel);
      var joinProfiler = _this._log.startTimer();

      var promises = [_this.connect(), utils.resolveOnEvent(_this, constants.COMMANDS.ROOM_STATE + '/' + channel)];

      if (!chatUtils.isUserAnonymous(_this.options.username)) {
        promises.push(utils.resolveOnEvent(_this, constants.COMMANDS.USER_STATE + '/' + channel));
      }

      var join = Promise.all(promises).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            roomState = _ref2[1],
            userState = _ref2[2];

        /**
         * @typedef {Object} ChannelState
         * Channel state information
         * @property {RoomStateTags} roomState
         * @property {?UserStateTags} userState
         */

        var channelState = {
          roomState: roomState.tags,
          userState: (0, _get4.default)(userState, 'tags', null)
        };

        _this._setChannelState(roomState.channel, channelState);

        joinProfiler.done({ message: 'Joined ' + channel });
        return channelState;
      });

      var send = _this.send(constants.COMMANDS.JOIN + ' ' + channel);

      return send.then(function () {
        return Promise.race([utils.rejectAfter(_this.options.joinTimeout, new Errors.TimeoutError(constants.ERROR_JOIN_TIMED_OUT)), join]);
      });
    };

    _this.part = function (maybeChannel) {
      var channel = sanitizers.channel(maybeChannel);
      _this._log.info('Parting ' + channel);

      _this._removeChannelState(channel);
      _this.send(constants.COMMANDS.PART + ' ' + channel);
    };

    _this.say = function (maybeChannel, message) {
      for (var _len = arguments.length, messageArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        messageArgs[_key - 2] = arguments[_key];
      }

      var channel = sanitizers.channel(maybeChannel);
      var args = messageArgs.length ? [''].concat(messageArgs).join(' ') : '';

      var info = 'PRIVMSG/' + channel + ' :' + message + args;

      var isModerator = (0, _get4.default)(_this, ['_channelState', channel, 'isModerator']);

      var timeout = utils.rejectAfter(_this.options.joinTimeout, constants.ERROR_SAY_TIMED_OUT);

      var commandResolvers = commands.resolvers(_this).apply(undefined, [channel, message].concat(messageArgs));

      var resolvers = function resolvers() {
        return Promise.race([timeout].concat(_toConsumableArray(commandResolvers)));
      };

      return utils.resolveInSequence([_this._isUserAuthenticated.bind(_this), _this.send.bind(_this, constants.COMMANDS.PRIVATE_MESSAGE + ' ' + channel + ' :' + message + args, { isModerator: isModerator }), resolvers]).then(function (resolvedEvent) {
        _this._log.info(info);
        return resolvedEvent;
      }).catch(function (err) {
        _this._log.error(info, err);
        return Promise.reject(err);
      });
    };

    _this.whisper = function (user, message) {
      return utils.resolveInSequence([_this._isUserAuthenticated.bind(_this), _this.send.bind(_this, constants.COMMANDS.WHISPER + ' :/w ' + user + ' ' + message)]);
    };

    _this.broadcast = function (message) {
      return utils.resolveInSequence([_this._isUserAuthenticated.bind(_this), function () {
        return Promise.all(_this._getChannels().map(function (channel) {
          return _this.say(channel, message);
        }));
      }]);
    };

    _this.options = maybeOptions;

    /**
     * @type {any}
     * @private
     */
    _this._log = (0, _create2.default)(_extends({ scope: 'Chat' }, _this.options.log));

    // Create commands.
    Object.assign(_this, commands.factory(_this));
    return _this;
  }

  /**
   * @function Chat#getOptions
   * @public
   * @desc Retrieves the current [ChatOptions]{@link Chat#ChatOptions}
   * @return {ChatOptions} Options of the client
   */

  /** @private */

  /** @private */


  /** @private */


  _createClass(Chat, [{
    key: 'updateOptions',


    /**
     * @function Chat#updateOptions
     * @public
     * @desc Updates the clients options after first instantiation.
     * @param {ApiOptions} options New client options. To update `token` or `username`, use [**api.reconnect()**]{@link Chat#reconnect}.
     */
    value: function updateOptions(options) {
      var _options = this.options,
          token = _options.token,
          username = _options.username;

      this.options = _extends({}, options, { token: token, username: username });
    }

    /**
     * @function Chat#send
     * @public
     * @desc Sends a raw message to Twitch.
     * @param {string} message - Message to send.
     * @return {Promise} Resolves on success, rejects on failure.
     */


    /**
     * @function Chat#disconnect
     * @public
     * @desc Disconnected from Twitch.
     */


    /**
     * @function Chat#reconnect
     * @public
     * @desc Reconnect to Twitch.
     * @param {object} newOptions Provide new options to client.
     * @return {Promise<Array<ChannelState>, string>}
     */


    /**
     * @function Chat#join
     * @public
     * @desc Join a channel.
     * @param {string} channel
     * @return {Promise<ChannelState, string>}
     *
     * @example <caption>Joining #dallas</caption>
     * const channel = '#dallas'
     *
     * chat.join(channel).then(channelState => {
     *   // Do stuff with channelState...
     * })
     *
     * @example <caption>Joining multiple channels</caption>
     * const channels = ['#dallas', '#ronni']
     *
     * Promise.all(channels.map(channel => chat.join(channel)))
     *   .then(channelStates => {
     *     // Listen to all PRIVMSG
     *     chat.on('PRIVMSG', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *
     *     // Listen to PRIVMSG from #dallas ONLY
     *     chat.on('PRIVMSG/#dallas', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *     // Listen to all PRIVMSG from #ronni ONLY
     *     chat.on('PRIVMSG/#ronni', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *   })
     */


    /**
     * @function Chat#part
     * @public
     * @desc Depart from a channel.
     * @param {string} channel
     */


    /**
     * @function Chat#say
     * @public
     * @desc Send a message to a channel.
     * @param {string} channel
     * @param {string} message
     * @return {Promise<?UserStateMessage, string>}
     */


    /**
     * @function Chat#whisper
     * @public
     * @desc Whisper to another user.
     * @param {string} user
     * @param {string} message
     * @return {Promise<undefined>}
     */


    /**
     * @function Chat#broadcast
     * @public
     * @desc Broadcast message to all connected channels.
     * @param {string} message
     * @return {Promise<Array<UserStateMessage>>}
     */

  }, {
    key: '_handleConnectionAttempt',
    value: function _handleConnectionAttempt() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var connectProfiler = _this2._log.startTimer({
          message: 'Connecting ...'
        });

        // Connect ...
        _this2._readyState = 1;

        // Increment connection attempts.
        _this2._connectionAttempts += 1;

        if (_this2._client) {
          // Remove all listeners, just in case.
          _this2._client.removeAllListeners();
        }

        // Create client and connect.
        _this2._client = new _Client2.default(_this2.options);

        // Handle messages.
        _this2._client.on(constants.EVENTS.ALL, _this2._handleMessage, _this2);

        // Handle disconnects.
        _this2._client.on(constants.EVENTS.DISCONNECTED, _this2._handleDisconnect, _this2);

        // Listen for reconnects.
        _this2._client.once(constants.EVENTS.RECONNECT, function () {
          return _this2.reconnect();
        });

        // Listen for authentication failures.
        _this2._client.once(constants.EVENTS.AUTHENTICATION_FAILED, reject);

        // Once the client is connected, resolve ...
        _this2._client.once(constants.EVENTS.CONNECTED, function (e) {
          connectProfiler.done({ message: 'Connected' });
          resolve(e);
        });
      });
    }
  }, {
    key: '_handleConnectSuccess',
    value: function _handleConnectSuccess(globalUserState) {
      this._readyState = 3;
      this._connectionAttempts = 0;

      // Process GLOBALUSERSTATE message.
      this._handleMessage(globalUserState);

      return globalUserState;
    }
  }, {
    key: '_handleConnectRetry',
    value: function _handleConnectRetry(error) {
      var _this3 = this;

      this._connectionInProgress = null;
      this._readyState = 2;

      this._log.info('Retrying ...');

      if (error.event === constants.EVENTS.AUTHENTICATION_FAILED) {
        return this.options.onAuthenticationFailure().then(function (token) {
          return _this3.options = _extends({}, _this3.options, { token: token });
        }).then(function () {
          return utils.resolveAfter(_this3.options.connectionTimeout);
        }).then(function () {
          return _this3.connect();
        }).catch(function () {
          _this3._log.error('Connection failed');
          throw new Errors.AuthenticationError(error);
        });
      }

      return this.connect();
    }
  }, {
    key: '_isUserAuthenticated',
    value: function _isUserAuthenticated() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (chatUtils.isUserAnonymous(_this4.options.username)) {
          reject(new Error('Not authenticated'));
        } else {
          resolve();
        }
      });
    }
  }, {
    key: '_emit',
    value: function _emit(eventName, message) {
      var _this5 = this;

      if (eventName) {
        var displayName = (0, _get4.default)(message, 'tags.displayName') || message.username || '';
        var info = (0, _get4.default)(message, 'message') || '';
        this._log.info('' + eventName, '' + displayName + (info ? ':' : ''), info);

        eventName.split('/').filter(function (part) {
          return part !== '#';
        }).reduce(function (parents, part) {
          var eventParts = [].concat(_toConsumableArray(parents), [part]);
          _get2(Chat.prototype.__proto__ || Object.getPrototypeOf(Chat.prototype), 'emit', _this5).call(_this5, eventParts.join('/'), message);
          return eventParts;
        }, []);
      }

      /**
       * All events are also emitted with this event name.
       * @event Chat#*
       */
      _get2(Chat.prototype.__proto__ || Object.getPrototypeOf(Chat.prototype), 'emit', this).call(this, constants.EVENTS.ALL, message);
    }
  }, {
    key: '_getChannels',
    value: function _getChannels() {
      return Object.keys(this._channelState);
    }
  }, {
    key: '_getChannelState',
    value: function _getChannelState(channel) {
      return this._channelState[channel];
    }
  }, {
    key: '_setChannelState',
    value: function _setChannelState(channel, state) {
      this._channelState[channel] = state;
    }
  }, {
    key: '_removeChannelState',
    value: function _removeChannelState(channel) {
      this._channelState = Object.entries(this._channelState).reduce(function (channelStates, _ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            name = _ref4[0],
            state = _ref4[1];

        return name === channel ? channelStates : _extends({}, channelStates, _defineProperty({}, name, state));
      }, {});
    }
  }, {
    key: '_clearChannelState',
    value: function _clearChannelState() {
      this._channelState = {};
    }
  }, {
    key: '_handleMessage',
    value: function _handleMessage(baseMessage) {
      var channel = sanitizers.channel(baseMessage.channel);

      var selfUsername = (0, _get4.default)(this, '_userState.username', '');
      var messageUsername = (0, _get4.default)(baseMessage, 'username');
      var isSelf = selfUsername === messageUsername;

      var preMessage = _extends({}, baseMessage, { isSelf: isSelf });

      var eventName = preMessage.command;
      var message = preMessage;

      switch (preMessage.command) {
        case constants.EVENTS.JOIN:
          {
            message = parsers.joinOrPartMessage(preMessage);
            message.isSelf = true;
            eventName = message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.PART:
          {
            message = parsers.joinOrPartMessage(preMessage);
            message.isSelf = true;
            eventName = message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.NAMES:
          {
            message = parsers.namesMessage(preMessage);
            message.isSelf = true;
            eventName = message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.NAMES_END:
          {
            message = parsers.namesEndMessage(preMessage);
            message.isSelf = true;
            eventName = message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.CLEAR_CHAT:
          {
            message = parsers.clearChatMessage(preMessage);
            eventName = message.event ? message.command + '/' + message.event + '/' + channel : message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.HOST_TARGET:
          {
            message = parsers.hostTargetMessage(preMessage);
            eventName = message.command + '/' + channel;
            break;
          }

        case constants.EVENTS.MODE:
          {
            message = parsers.modeMessage(preMessage);
            eventName = message.command + '/' + channel;

            if (selfUsername === message.username) {
              var channelState = this._getChannelState(channel);

              this._setChannelState(channel, _extends({}, channelState, {
                userState: _extends({}, channelState.userState, {
                  isModerator: message.isModerator
                })
              }));
            }
            break;
          }

        case constants.EVENTS.GLOBAL_USER_STATE:
          {
            message = parsers.globalUserStateMessage(preMessage);
            this._userState = message.tags;
            break;
          }

        case constants.EVENTS.USER_STATE:
          {
            message = parsers.userStateMessage(preMessage);
            eventName = message.command + '/' + channel;

            this._setChannelState(channel, _extends({}, this._getChannelState(channel), {
              userState: message.tags
            }));
            break;
          }

        case constants.EVENTS.ROOM_STATE:
          {
            message = parsers.roomStateMessage(preMessage);
            eventName = message.command + '/' + channel;

            this._setChannelState(channel, _extends({}, this._getChannelState(channel), {
              roomState: message.roomState
            }));
            break;
          }

        case constants.EVENTS.NOTICE:
          {
            message = parsers.noticeMessage(preMessage);
            eventName = message.command + '/' + message.event + '/' + channel;
            break;
          }

        case constants.EVENTS.USER_NOTICE:
          {
            message = parsers.userNoticeMessage(preMessage);
            eventName = message.command + '/' + message.event + '/' + channel;
            break;
          }

        case constants.EVENTS.PRIVATE_MESSAGE:
          {
            message = parsers.privateMessage(preMessage);
            eventName = message.event ? message.command + '/' + message.event + '/' + channel : message.command + '/' + channel;
            break;
          }

        default:
          {
            var command = chatUtils.getEventNameFromMessage(preMessage);
            eventName = channel === '#' ? command : command + '/' + channel;
          }
      }

      this._emit(eventName, message);
    }
  }, {
    key: '_handleDisconnect',
    value: function _handleDisconnect() {
      this._connectionInProgress = null;
      this._readyState = 5;
    }
  }, {
    key: 'options',
    get: function get() {
      return this._options;
    }

    /**
     * @function Chat#setOptions
     * @public
     * @desc Validates the passed options before changing `_options`
     * @param {ChatOptions} options
     */
    ,
    set: function set(maybeOptions) {
      this._options = validators.chatOptions(maybeOptions);
    }

    /**
     * @function Chat#connect
     * @public
     * @desc Connect to Twitch.
     * @return {Promise<?GlobalUserStateMessage, string>} Global user state message
     */

  }]);

  return Chat;
}(_eventemitter.EventEmitter);

exports.constants = constants;
exports.default = Chat;
//# sourceMappingURL=index.js.map