'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _betterQueue = require('better-queue');

var _betterQueue2 = _interopRequireDefault(_betterQueue);

var _betterQueueMemory = require('better-queue-memory');

var _betterQueueMemory2 = _interopRequireDefault(_betterQueueMemory);

var _setImmediate = require('core-js/library/fn/set-immediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _constants = require('./constants');

var constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Queue = function Queue() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Queue);

  this._length = 0;
  this._timestamp = new Date();
  this._callbacks = {};

  this.push = function (_ref) {
    var fn = _ref.fn,
        priority = _ref.priority;

    return _this._q.push({ fn: fn, priority: priority }).on('accepted', _this._handleTaskQueued).on('finish', _this._handleTaskFinished);
  };

  this._handlePriority = function (_ref2, cb) {
    var _ref2$priority = _ref2.priority,
        priority = _ref2$priority === undefined ? 1 : _ref2$priority;
    return cb(null, priority);
  };

  this._handlePrecondition = function (cb) {
    var now = new Date();
    if (now - _this._timestamp > _this._tickInterval) {
      _this._timestamp = now;
      _this._length = Math.max(0, _this._length - _this._maxLength);
    }

    cb(null, _this._length < _this._maxLength);
  };

  this._handleTaskQueued = function (taskId, task) {
    _this._callbacks.onTaskQueued(taskId, task);
  };

  this._handleTaskFinished = function (taskId, result) {
    var now = new Date();
    if (now - _this._timestamp > _this._tickInterval) {
      _this._timestamp = new Date();
    }

    _this._length = _this._length + 1;

    _this._callbacks.onTaskFinished(taskId, result);
  };

  this._handleQueueDrained = function () {
    _this._callbacks.onQueueDrained();
  };

  var _options$maxLength = options.maxLength,
      maxLength = _options$maxLength === undefined ? 20 : _options$maxLength,
      _options$tickInterval = options.tickInterval,
      tickInterval = _options$tickInterval === undefined ? 30000 : _options$tickInterval,
      _options$onTaskQueued = options.onTaskQueued,
      onTaskQueued = _options$onTaskQueued === undefined ? function () {} : _options$onTaskQueued,
      _options$onTaskFinish = options.onTaskFinished,
      onTaskFinished = _options$onTaskFinish === undefined ? function () {} : _options$onTaskFinish,
      _options$onQueueDrain = options.onQueueDrained,
      onQueueDrained = _options$onQueueDrain === undefined ? function () {} : _options$onQueueDrain;


  this._maxLength = maxLength;
  this._tickInterval = tickInterval;

  this._callbacks = { onTaskQueued: onTaskQueued, onTaskFinished: onTaskFinished, onQueueDrained: onQueueDrained };

  this._q = new _betterQueue2.default(function (_ref3, cb) {
    var fn = _ref3.fn;

    fn();
    cb();
  }, {
    store: new _betterQueueMemory2.default(),
    setImmediate: _setImmediate2.default,
    priority: this._handlePriority,
    precondition: this._handlePrecondition,
    preconditionRetryTimeout: constants.QUEUE_TICK_RATE
  });

  this._q.on('drain', this._handleQueueDrained);
};

exports.default = Queue;
//# sourceMappingURL=index.js.map