'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toLower2 = require('lodash/toLower');

var _toLower3 = _interopRequireDefault(_toLower2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _create = require('../utils/logger/create');

var _create2 = _interopRequireDefault(_create);

var _fetch = require('../utils/fetch');

var _fetch2 = _interopRequireDefault(_fetch);

var _Errors = require('../utils/fetch/Errors');

var Errors = _interopRequireWildcard(_Errors);

var _validators = require('./utils/validators');

var validators = _interopRequireWildcard(_validators);

var _constants = require('./constants');

var constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 * @public
 *
 * @example <caption>Get Featured Streams</caption>
 * const token = 'cfabdegwdoklmawdzdo98xt2fo512y'
 * const username = 'ronni'
 * const { api } = new TwitchJs({ token, username })
 *
 * api.get('streams/featured').then(response => {
 *   // Do stuff ...
 * })
 */
var Api = function () {

  /**
   * API constructor.
   * @param {ApiOptions} options
   */


  /**
   * API ready state
   * @private
   * @type {ApiReadyState}
   */
  function Api() {
    var maybeOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Api);

    this._readyState = 1;

    /**
     * @type {ApiOptions}
     * @private
     */
    this.options = maybeOptions;

    this._log = (0, _create2.default)(_extends({ scope: 'Api' }, this.options.log));
  }

  /**
   * @function Api#setOptions
   * @public
   * @param {ApiOptions} options
   */


  /**
   * API status state.
   * @typedef {Object} ApiStatusState
   * @property {Object} token
   * @property {Object} token.authorization
   * @property {Array<string>} token.authorization.scopes
   * @property {string} token.authorization.createdAt
   * @property {string} token.authorization.updatedAt
   * @property {string} token.clientId
   * @property {string} token.userId
   * @property {string} token.userName
   * @property {boolean} token.valid
   */
  /**
   * API status.
   * @private
   * @type {ApiStatusState}
   */


  _createClass(Api, [{
    key: 'updateOptions',


    /**
     * Update client options.
     * @function Api#updateOptions
     * @public
     * @param {ApiOptions} options New client options. To update `token` or `clientId`, use [**api.initialize()**]{@link Api#initialize}.
     */
    value: function updateOptions(options) {
      var _options = this.options,
          clientId = _options.clientId,
          token = _options.token;

      this.options = _extends({}, options, { clientId: clientId, token: token });
    }

    /**
     * @function Api#initialize
     * @private
     * Initialize API client and retrieve status.
     * @param {ApiOptions} [options] Provide new options to client.
     * @returns {Promise<ApiStatusState, Object>}
     * @see https://dev.twitch.tv/docs/v5/#root-url
     */

  }, {
    key: 'initialize',
    value: function initialize(newOptions) {
      var _this = this;

      if (newOptions) {
        this.options = _extends({}, this.options, newOptions);
      }

      if (!newOptions && this.readyState === 2) {
        return Promise.resolve();
      }

      return this.get().then(function (statusResponse) {
        _this._readyState = 2;
        _this._status = statusResponse;

        return statusResponse;
      });
    }

    /**
     * @function Api#hasScope
     * @private
     * Check if current credentials include `scope`.
     * @param {string} scope Scope to check.
     * @return {Promise<boolean, boolean>}
     * @see https://dev.twitch.tv/docs/authentication/#twitch-api-v5
     */

  }, {
    key: 'hasScope',
    value: function hasScope(scope) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.readyState !== 2) {
          return reject(false);
        }

        return (0, _includes3.default)((0, _get3.default)(_this2.status, 'token.authorization.scopes', []), scope) ? resolve(true) : reject(false);
      });
    }

    /**
     * @function Api#get
     * @public
     * GET endpoint.
     * @param {string} endpoint
     * @param {FetchOptions} [options]
     * @param {string} [options.version]
     *
     * @example <caption>Get Live Overwatch Streams</caption>
     * api.get('streams', { search: { game: 'Overwatch' } })
     *   .then(response => {
     *     // Do stuff with response ...
     *   })
     * @example <caption>Get user follows (Helix)</caption>
     * api.get('users/follows', { version: 'helix', search: { to_id: '23161357' } })
     *   .then(response => {
     *     // Do stuff with response ...
     *   })
     */

  }, {
    key: 'get',
    value: function get(endpoint) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this._handleFetch(endpoint, options);
    }

    /**
     * @function Api#post
     * @public
     * POST endpoint.
     * @param {string} endpoint
     * @param {FetchOptions} [options={method:'post'}]
     * @param {string} [options.version]
     */

  }, {
    key: 'post',
    value: function post(endpoint) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this._handleFetch(endpoint, _extends({}, options, { method: 'post' }));
    }

    /**
     * @function Api#put
     * @public
     * PUT endpoint.
     * @param {string} endpoint
     * @param {FetchOptions} [options={method:'put'}]
     * @param {string} [options.version]
     */

  }, {
    key: 'put',
    value: function put(endpoint) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this._handleFetch(endpoint, _extends({}, options, { method: 'put' }));
    }
  }, {
    key: '_isVersionHelix',
    value: function _isVersionHelix(version) {
      return (0, _toLower3.default)(version) === constants.HELIX_VERSION;
    }
  }, {
    key: '_getBaseUrl',
    value: function _getBaseUrl() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          version = _ref.version;

      return this._isVersionHelix(version) ? constants.HELIX_URL_ROOT : constants.KRAKEN_URL_ROOT;
    }
  }, {
    key: '_getHeaders',
    value: function _getHeaders() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          version = _ref2.version;

      var _options2 = this.options,
          clientId = _options2.clientId,
          token = _options2.token;


      var isHelix = this._isVersionHelix(version);

      var authorizationHeader = isHelix ? constants.HELIX_AUTHORIZATION_HEADER : constants.KRAKEN_AUTHORIZATION_HEADER;
      var authorization = authorizationHeader + ' ' + token;

      var headers = isHelix ? {} : { Accept: 'application/vnd.twitchtv.v5+json' };

      if (!clientId) {
        return _extends({}, headers, { Authorization: authorization });
      } else if (!token) {
        return _extends({}, headers, { 'Client-ID': clientId });
      }

      return _extends({}, headers, {
        'Client-ID': clientId,
        Authorization: authorization
      });
    }
  }, {
    key: '_handleFetch',
    value: function _handleFetch() {
      var _this3 = this;

      var maybeUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var fetchProfiler = this._log.startTimer();

      var version = options.version,
          fetchOptions = _objectWithoutProperties(options, ['version']);

      var baseUrl = this._getBaseUrl({ version: version });
      var headers = this._getHeaders({ version: version });

      var url = baseUrl + '/' + maybeUrl;

      var message = (fetchOptions.method || 'GET') + ' ' + baseUrl;

      var request = function request() {
        return (0, _fetch2.default)(url, _extends({}, fetchOptions, {
          headers: _extends({}, fetchOptions.headers, headers)
        })).then(function (res) {
          fetchProfiler.done({ message: message });
          return res;
        });
      };

      return request().catch(function (error) {
        fetchProfiler.done({ level: 'error', message: error.body });

        if (error instanceof Errors.AuthenticationError) {
          return _this3.options.onAuthenticationFailure().then(function (token) {
            return _this3.options = _extends({}, _this3.options, { token: token });
          }).then(function () {
            return _this3._log.info('Retrying (with new credentials)');
          }).then(function () {
            return request();
          });
        }

        throw error;
      });
    }
  }, {
    key: 'options',
    set: function set(maybeOptions) {
      this._options = validators.apiOptions(maybeOptions);
    }

    /**
     * @function Api#getOptions
     * @public
     * @return {ApiOptions}
     */
    ,
    get: function get() {
      return this._options;
    }

    /**
     * @function Api#getReadyState
     * @public
     * @return {number}
     *
     */

  }, {
    key: 'readyState',
    get: function get() {
      return this._readyState;
    }

    /**
     * @function Api#getStatus
     * @public
     * @return {ApiStatusState}
     */

  }, {
    key: 'status',
    get: function get() {
      return this._status;
    }
  }]);

  return Api;
}();

exports.default = Api;
//# sourceMappingURL=index.js.map